<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ssuds::ArrayList&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacessuds.html">ssuds</a></li><li class="navelem"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classssuds_1_1_array_list-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ssuds::ArrayList&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> is an array-based data structure.  
 <a href="classssuds_1_1_array_list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_lists_8h_source.html">arrayLists.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The job of <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is to traverse the data in an <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> wouldn't necessarily <em>need</em> an iterator since the internal array supports random access, but this is a chance to get used to the iterator pattern, which is much more useful for the user in other classes. We might eventually use inheritance to derive this class from some common iterator class.  <a href="classssuds_1_1_array_list_1_1_array_list_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a8f2e0b06a3bf7bdc5fbe20c95cec1c6b">operator[]</a> (int index) const</td></tr>
<tr class="memdesc:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data item at the given index. This method (unlike at) does NOT do bounds-checking (and so is very slightly faster)  <br /></td></tr>
<tr class="separator:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6334ec5abee5dbc48aafcdf46a390670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a6334ec5abee5dbc48aafcdf46a390670">operator=</a> (const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a6334ec5abee5dbc48aafcdf46a390670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the creation of a deep copy when the user assigns an existing <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> to another. This method also handles the case where the user self-copies (a = a).  <br /></td></tr>
<tr class="separator:a6334ec5abee5dbc48aafcdf46a390670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17073605b1b8e31ca126e61db633c57d"><td class="memItemLeft" align="right" valign="top"><a id="a17073605b1b8e31ca126e61db633c57d" name="a17073605b1b8e31ca126e61db633c57d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> ()</td></tr>
<tr class="memdesc:a17073605b1b8e31ca126e61db633c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Default constructor. <br /></td></tr>
<tr class="separator:a17073605b1b8e31ca126e61db633c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8c635fece5189238f20e4df1e9e899"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#acc8c635fece5189238f20e4df1e9e899">ArrayList</a> (const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;other)</td></tr>
<tr class="memdesc:acc8c635fece5189238f20e4df1e9e899"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy-constructor. Used in these two cases <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me(other_array_list); <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me = other_array_list; Note: this does NOT use the =operator ... me = other_array_list; This WOULD use the =operator.  <br /></td></tr>
<tr class="separator:acc8c635fece5189238f20e4df1e9e899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad351338073d3009c376cc41ebd1a3fa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#ad351338073d3009c376cc41ebd1a3fa1">ArrayList</a> (<a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ad351338073d3009c376cc41ebd1a3fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move-constructor. This makes a shallow copy of other. A better way to explain might be to say that this constructor "steals" the data from the other array. The compiler calls this method when <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> other is about to go away, and it is being assigned to us. Making a full copy would be much more expensive than this.  <br /></td></tr>
<tr class="separator:ad351338073d3009c376cc41ebd1a3fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2054692182bb324c826024ccc10a63b7"><td class="memItemLeft" align="right" valign="top"><a id="a2054692182bb324c826024ccc10a63b7" name="a2054692182bb324c826024ccc10a63b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a2054692182bb324c826024ccc10a63b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. <br /></td></tr>
<tr class="separator:a2054692182bb324c826024ccc10a63b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e1f8861f34a0da7230aeec7571e3c"><td class="memItemLeft" align="right" valign="top"><a id="a334e1f8861f34a0da7230aeec7571e3c" name="a334e1f8861f34a0da7230aeec7571e3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ArrayList</b> ()</td></tr>
<tr class="memdesc:a334e1f8861f34a0da7230aeec7571e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a334e1f8861f34a0da7230aeec7571e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7c9bd58748ea361ca69b45c1c66681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a3a7c9bd58748ea361ca69b45c1c66681">append</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a3a7c9bd58748ea361ca69b45c1c66681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the end of the array.  <br /></td></tr>
<tr class="separator:a3a7c9bd58748ea361ca69b45c1c66681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b660cd011f7d236e41e8602412072a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a78b660cd011f7d236e41e8602412072a">at</a> (const unsigned int index) const</td></tr>
<tr class="memdesc:a78b660cd011f7d236e41e8602412072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the item at the given index. Since it is a reference, this type of operation is allowed: my_float_array.at(5) = 17.3f; my_int_array.at(3)++; This method will raise a std::out_of_range exception if an invalid index is given.  <br /></td></tr>
<tr class="separator:a78b660cd011f7d236e41e8602412072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b21ab65dae2e027da6d40e1214ebb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a1b21ab65dae2e027da6d40e1214ebb6c">begin</a> () const</td></tr>
<tr class="memdesc:a1b21ab65dae2e027da6d40e1214ebb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an forward <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the first element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to end.  <br /></td></tr>
<tr class="separator:a1b21ab65dae2e027da6d40e1214ebb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9f0d67b921ddde2da06bdef3012ca8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a4e9f0d67b921ddde2da06bdef3012ca8">capacity</a> () const</td></tr>
<tr class="memdesc:a4e9f0d67b921ddde2da06bdef3012ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> (this is always greater than or equal to the size)  <br /></td></tr>
<tr class="separator:a4e9f0d67b921ddde2da06bdef3012ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9aaf226d5c6fde758546102150271"><td class="memItemLeft" align="right" valign="top"><a id="a29f9aaf226d5c6fde758546102150271" name="a29f9aaf226d5c6fde758546102150271"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a29f9aaf226d5c6fde758546102150271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the array back to its original state. <br /></td></tr>
<tr class="separator:a29f9aaf226d5c6fde758546102150271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f6f81f6ab34575525ed973c81146d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#ae89f6f81f6ab34575525ed973c81146d">end</a> () const</td></tr>
<tr class="memdesc:ae89f6f81f6ab34575525ed973c81146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name can be a bit mis-leading, but this iterator does NOT return an iterator referring to the LAST element. Instead, it returns a special value that indicates this is an invalid iterator (or we're done forward-traversing)  <br /></td></tr>
<tr class="separator:ae89f6f81f6ab34575525ed973c81146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82856a033e2fd787203e1980c912b894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a82856a033e2fd787203e1980c912b894">find</a> (const T &amp;val, const unsigned int start_index=0) const</td></tr>
<tr class="memdesc:a82856a033e2fd787203e1980c912b894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first occurrence of the given value.  <br /></td></tr>
<tr class="separator:a82856a033e2fd787203e1980c912b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a729905bcedb0b493d51d8ad6af594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#aa6a729905bcedb0b493d51d8ad6af594">find</a> (const T &amp;val, const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;start) const</td></tr>
<tr class="memdesc:aa6a729905bcedb0b493d51d8ad6af594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the find method above, but using iterators (closer to std::vector)  <br /></td></tr>
<tr class="separator:aa6a729905bcedb0b493d51d8ad6af594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#abd03aedf6acb7f37086d83a4b5ed9dd2">insert</a> (const T &amp;val, unsigned int index)</td></tr>
<tr class="memdesc:abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new data item at a given index.  <br /></td></tr>
<tr class="separator:abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb940eeacbdef50b05dac3f2e681ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a8fb940eeacbdef50b05dac3f2e681ab8">output</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a8fb940eeacbdef50b05dac3f2e681ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This basically does the same thing as the &lt;&lt; operator (the syntax is a bit different). I chose to keep it to preserve backwards compatiability with &lt;Lab3 code.  <br /></td></tr>
<tr class="separator:a8fb940eeacbdef50b05dac3f2e681ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff369eaa7e49b33bcfa80aa88906fcd"><td class="memItemLeft" align="right" valign="top"><a id="a3ff369eaa7e49b33bcfa80aa88906fcd" name="a3ff369eaa7e49b33bcfa80aa88906fcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (const T &amp;val)</td></tr>
<tr class="separator:a3ff369eaa7e49b33bcfa80aa88906fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcec39c654ee0a0d25d033809b1af44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#abfcec39c654ee0a0d25d033809b1af44">rbegin</a> () const</td></tr>
<tr class="memdesc:abfcec39c654ee0a0d25d033809b1af44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a backwards <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the last element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to rend.  <br /></td></tr>
<tr class="separator:abfcec39c654ee0a0d25d033809b1af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c6c8324263cb02cad484f59bf0039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a8d4c6c8324263cb02cad484f59bf0039">rend</a> () const</td></tr>
<tr class="memdesc:a8d4c6c8324263cb02cad484f59bf0039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a special value indicating we're done iterating backwards or that this iterator is invalid.  <br /></td></tr>
<tr class="separator:a8d4c6c8324263cb02cad484f59bf0039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8ccd2d3ede88c6041032f2acb7bc17"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#afb8ccd2d3ede88c6041032f2acb7bc17">remove</a> (unsigned int index, bool resize_if_necessary=true)</td></tr>
<tr class="memdesc:afb8ccd2d3ede88c6041032f2acb7bc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a data item at the given index.  <br /></td></tr>
<tr class="separator:afb8ccd2d3ede88c6041032f2acb7bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a4aaf7be94a8d5c7c7a54cc9a4ee58763">remove</a> (const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value at the given position.  <br /></td></tr>
<tr class="separator:a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a47e4c18bb5fbcacabf07fb7cad038f9b">remove_all</a> (const T val, bool resize_if_necessary=true)</td></tr>
<tr class="memdesc:a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all occurrences of a given value. Uses find and remove internally to do the removal.  <br /></td></tr>
<tr class="separator:a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891330426da480ed1bbbfb29fb018b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a891330426da480ed1bbbfb29fb018b3a">reserve</a> (unsigned int desired_capacity)</td></tr>
<tr class="memdesc:a891330426da480ed1bbbfb29fb018b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures the internal array has at least this capacity. This is useful if the user knows how many items they will add and don't want to take the performance penalty of the grow operation happening in-between. If the capacity is already higher or equal to the given value, there will be no effect.  <br /></td></tr>
<tr class="separator:a891330426da480ed1bbbfb29fb018b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd61184deb92c36610e47b91a7b6d5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#adbcd61184deb92c36610e47b91a7b6d5">size</a> () const</td></tr>
<tr class="memdesc:adbcd61184deb92c36610e47b91a7b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the internal array (i.e.) how many things are being stored in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>.  <br /></td></tr>
<tr class="separator:adbcd61184deb92c36610e47b91a7b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17073605b1b8e31ca126e61db633c57d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a17073605b1b8e31ca126e61db633c57d">ArrayList</a> ()</td></tr>
<tr class="memdesc:a17073605b1b8e31ca126e61db633c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates array of given type  <br /></td></tr>
<tr class="separator:a17073605b1b8e31ca126e61db633c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d4f5da0c2880eb7352b1bbfefed226"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#aa8d4f5da0c2880eb7352b1bbfefed226">ArrayList</a> (unsigned int <a class="el" href="classssuds_1_1_array_list.html#a4e9f0d67b921ddde2da06bdef3012ca8">capacity</a>)</td></tr>
<tr class="memdesc:aa8d4f5da0c2880eb7352b1bbfefed226"><td class="mdescLeft">&#160;</td><td class="mdescRight">create and array list with an assigned capacity  <br /></td></tr>
<tr class="separator:aa8d4f5da0c2880eb7352b1bbfefed226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022f6327709060fe26bd05dc6b02b480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a022f6327709060fe26bd05dc6b02b480">append</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a022f6327709060fe26bd05dc6b02b480"><td class="mdescLeft">&#160;</td><td class="mdescRight">add new instance to end of the array  <br /></td></tr>
<tr class="separator:a022f6327709060fe26bd05dc6b02b480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4898f36024650dee875d67083f344481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a4898f36024650dee875d67083f344481">prepend</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a4898f36024650dee875d67083f344481"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a new instance to the beginning of the array  <br /></td></tr>
<tr class="separator:a4898f36024650dee875d67083f344481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbdc7476f393750c09dc73c9ebe439f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#adfbdc7476f393750c09dc73c9ebe439f">insert</a> (const T &amp;item, int index)</td></tr>
<tr class="memdesc:adfbdc7476f393750c09dc73c9ebe439f"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts given item at given index of the array  <br /></td></tr>
<tr class="separator:adfbdc7476f393750c09dc73c9ebe439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f9bf49676de4539ce9c5d56ebd642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#ae86f9bf49676de4539ce9c5d56ebd642">remove</a> (int index)</td></tr>
<tr class="memdesc:ae86f9bf49676de4539ce9c5d56ebd642"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes item from array at given index  <br /></td></tr>
<tr class="separator:ae86f9bf49676de4539ce9c5d56ebd642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef030038f51c7cb5b088cbd78b60d3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a3ef030038f51c7cb5b088cbd78b60d3c">remove_all</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a3ef030038f51c7cb5b088cbd78b60d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all occurrences of the same value  <br /></td></tr>
<tr class="separator:a3ef030038f51c7cb5b088cbd78b60d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21980af4d57634155e163a33433ae1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a7a21980af4d57634155e163a33433ae1">at</a> (int index)</td></tr>
<tr class="memdesc:a7a21980af4d57634155e163a33433ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">looks for an item at given index and returns a reference to the item.  <br /></td></tr>
<tr class="separator:a7a21980af4d57634155e163a33433ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f5188f57d95a55b2606583e0dc77ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a49f5188f57d95a55b2606583e0dc77ef">find</a> (const T &amp;valueRef)</td></tr>
<tr class="memdesc:a49f5188f57d95a55b2606583e0dc77ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the given reference value  <br /></td></tr>
<tr class="separator:a49f5188f57d95a55b2606583e0dc77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60772231478d29dfb81a2214bc17e4f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#af60772231478d29dfb81a2214bc17e4f">size</a> ()</td></tr>
<tr class="memdesc:af60772231478d29dfb81a2214bc17e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets number of instances in array  <br /></td></tr>
<tr class="separator:af60772231478d29dfb81a2214bc17e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5630efb680996c89e6b45e2a70a79c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a8b5630efb680996c89e6b45e2a70a79c">capacity</a> ()</td></tr>
<tr class="memdesc:a8b5630efb680996c89e6b45e2a70a79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the capacity of the array  <br /></td></tr>
<tr class="separator:a8b5630efb680996c89e6b45e2a70a79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602f27aeca5467f893fe3d8f9a4a369c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a602f27aeca5467f893fe3d8f9a4a369c">reserve</a> (int newCapacity)</td></tr>
<tr class="memdesc:a602f27aeca5467f893fe3d8f9a4a369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">resises array to a desired capactiy.  <br /></td></tr>
<tr class="separator:a602f27aeca5467f893fe3d8f9a4a369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7f6aaf5c3991f6ab2ff4bd88cb1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#addd7f6aaf5c3991f6ab2ff4bd88cb1a4">output</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:addd7f6aaf5c3991f6ab2ff4bd88cb1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates output to an ostream  <br /></td></tr>
<tr class="separator:addd7f6aaf5c3991f6ab2ff4bd88cb1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e1f8861f34a0da7230aeec7571e3c"><td class="memItemLeft" align="right" valign="top"><a id="a334e1f8861f34a0da7230aeec7571e3c" name="a334e1f8861f34a0da7230aeec7571e3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ArrayList</b> ()</td></tr>
<tr class="memdesc:a334e1f8861f34a0da7230aeec7571e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">freeing all the memory and destroying array <br /></td></tr>
<tr class="separator:a334e1f8861f34a0da7230aeec7571e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dedef119a00eb58d4118e45919b9d3"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#aa4dedef119a00eb58d4118e45919b9d3">operator[]</a> (int index)</td></tr>
<tr class="memdesc:aa4dedef119a00eb58d4118e45919b9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the [] operator to return the value by index  <br /></td></tr>
<tr class="separator:aa4dedef119a00eb58d4118e45919b9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d38b6e2574880f07422497f468ddd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a29d38b6e2574880f07422497f468ddd8">begin</a> ()</td></tr>
<tr class="memdesc:a29d38b6e2574880f07422497f468ddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the beginning iterator  <br /></td></tr>
<tr class="separator:a29d38b6e2574880f07422497f468ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807800c2ae6c98f36604c1e5a03ea8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a807800c2ae6c98f36604c1e5a03ea8ca">end</a> ()</td></tr>
<tr class="memdesc:a807800c2ae6c98f36604c1e5a03ea8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the ending iterator  <br /></td></tr>
<tr class="separator:a807800c2ae6c98f36604c1e5a03ea8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="memItemLeft" align="right" valign="top"><a id="a07a02cc34fc7c9162e64e3c7a7d1a963" name="a07a02cc34fc7c9162e64e3c7a7d1a963"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>grow</b> ()</td></tr>
<tr class="memdesc:a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal method to resize the array if we are currently at capacity (if we are not, nothing is done) <br /></td></tr>
<tr class="separator:a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18613568842335b1d115958d2f34bab"><td class="memItemLeft" align="right" valign="top"><a id="ae18613568842335b1d115958d2f34bab" name="ae18613568842335b1d115958d2f34bab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink</b> ()</td></tr>
<tr class="memdesc:ae18613568842335b1d115958d2f34bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal method to see if the array can be shrunk (capacity reduced by half, down to msMinCapacity) <br /></td></tr>
<tr class="separator:ae18613568842335b1d115958d2f34bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac4487ae34800f88539054c3721568c10"><td class="memItemLeft" align="right" valign="top"><a id="ac4487ae34800f88539054c3721568c10" name="ac4487ae34800f88539054c3721568c10"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mCapacity</b></td></tr>
<tr class="memdesc:ac4487ae34800f88539054c3721568c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of "slots" AVAILABLE in mData (i.e. the array size) <br /></td></tr>
<tr class="separator:ac4487ae34800f88539054c3721568c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f68ee08bdbaa2f26d017816e4e46e42"><td class="memItemLeft" align="right" valign="top"><a id="a8f68ee08bdbaa2f26d017816e4e46e42" name="a8f68ee08bdbaa2f26d017816e4e46e42"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mSize</b></td></tr>
<tr class="memdesc:a8f68ee08bdbaa2f26d017816e4e46e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many slots are we USING? This will always be less than or equal to mCapacity. <br /></td></tr>
<tr class="separator:a8f68ee08bdbaa2f26d017816e4e46e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c344eccee75213eb02e96ea3e300e"><td class="memItemLeft" align="right" valign="top"><a id="ae43c344eccee75213eb02e96ea3e300e" name="ae43c344eccee75213eb02e96ea3e300e"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>mData</b></td></tr>
<tr class="separator:ae43c344eccee75213eb02e96ea3e300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="memItemLeft" align="right" valign="top"><a id="a5b588e6e70c9a9b5cacbc7ce5b971490" name="a5b588e6e70c9a9b5cacbc7ce5b971490"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>msMinCapacity</b> = 5</td></tr>
<tr class="memdesc:a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default (and minimum) capacity of an <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. <br /></td></tr>
<tr class="separator:a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a9bb180c1f0d6bbe33037e1a8b0d6f5e4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;alist)</td></tr>
<tr class="memdesc:a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the stream operator for ArrayLists.  <br /></td></tr>
<tr class="separator:a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3240f50cbf31ab8d25e1a336017d84"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list.html#a0a3240f50cbf31ab8d25e1a336017d84">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;A)</td></tr>
<tr class="memdesc:a0a3240f50cbf31ab8d25e1a336017d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload the &lt;&lt; operator for easy printing.  <br /></td></tr>
<tr class="separator:a0a3240f50cbf31ab8d25e1a336017d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class ssuds::ArrayList&lt; T &gt;</div><p>An <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> is an array-based data structure. </p>
<p>Makes an array of any given type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc8c635fece5189238f20e4df1e9e899" name="acc8c635fece5189238f20e4df1e9e899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8c635fece5189238f20e4df1e9e899">&#9670;&#160;</a></span>ArrayList() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy-constructor. Used in these two cases <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me(other_array_list); <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me = other_array_list; Note: this does NOT use the =operator ... me = other_array_list; This WOULD use the =operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad351338073d3009c376cc41ebd1a3fa1" name="ad351338073d3009c376cc41ebd1a3fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad351338073d3009c376cc41ebd1a3fa1">&#9670;&#160;</a></span>ArrayList() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move-constructor. This makes a shallow copy of other. A better way to explain might be to say that this constructor "steals" the data from the other array. The compiler calls this method when <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> other is about to go away, and it is being assigned to us. Making a full copy would be much more expensive than this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17073605b1b8e31ca126e61db633c57d" name="a17073605b1b8e31ca126e61db633c57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17073605b1b8e31ca126e61db633c57d">&#9670;&#160;</a></span>ArrayList() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates array of given type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>class or data type of array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d4f5da0c2880eb7352b1bbfefed226" name="aa8d4f5da0c2880eb7352b1bbfefed226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d4f5da0c2880eb7352b1bbfefed226">&#9670;&#160;</a></span>ArrayList() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create and array list with an assigned capacity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>number of items that can fit inside the array.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a022f6327709060fe26bd05dc6b02b480" name="a022f6327709060fe26bd05dc6b02b480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022f6327709060fe26bd05dc6b02b480">&#9670;&#160;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add new instance to end of the array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>object instance being added to array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a7c9bd58748ea361ca69b45c1c66681" name="a3a7c9bd58748ea361ca69b45c1c66681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c9bd58748ea361ca69b45c1c66681">&#9670;&#160;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the end of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the new value to add</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b660cd011f7d236e41e8602412072a" name="a78b660cd011f7d236e41e8602412072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b660cd011f7d236e41e8602412072a">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the item at the given index. Since it is a reference, this type of operation is allowed: my_float_array.at(5) = 17.3f; my_int_array.at(3)++; This method will raise a std::out_of_range exception if an invalid index is given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7a21980af4d57634155e163a33433ae1" name="a7a21980af4d57634155e163a33433ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a21980af4d57634155e163a33433ae1">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>looks for an item at given index and returns a reference to the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of desired item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to desired item</dd></dl>

</div>
</div>
<a id="a29d38b6e2574880f07422497f468ddd8" name="a29d38b6e2574880f07422497f468ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d38b6e2574880f07422497f468ddd8">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the beginning iterator </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> with a pos of 0</dd></dl>

</div>
</div>
<a id="a1b21ab65dae2e027da6d40e1214ebb6c" name="a1b21ab65dae2e027da6d40e1214ebb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b21ab65dae2e027da6d40e1214ebb6c">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an forward <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the first element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to end. </p>
<dl class="section return"><dt>Returns</dt><dd>A forward iterator referring to the first value value</dd></dl>

</div>
</div>
<a id="a8b5630efb680996c89e6b45e2a70a79c" name="a8b5630efb680996c89e6b45e2a70a79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5630efb680996c89e6b45e2a70a79c">&#9670;&#160;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the capacity of the array </p>
<dl class="section return"><dt>Returns</dt><dd>size of array</dd></dl>

</div>
</div>
<a id="a4e9f0d67b921ddde2da06bdef3012ca8" name="a4e9f0d67b921ddde2da06bdef3012ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9f0d67b921ddde2da06bdef3012ca8">&#9670;&#160;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> (this is always greater than or equal to the size) </p>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the internal array in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<a id="a807800c2ae6c98f36604c1e5a03ea8ca" name="a807800c2ae6c98f36604c1e5a03ea8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807800c2ae6c98f36604c1e5a03ea8ca">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the ending iterator </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> with a pos of -1. This signifies it as the null or end of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<a id="ae89f6f81f6ab34575525ed973c81146d" name="ae89f6f81f6ab34575525ed973c81146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89f6f81f6ab34575525ed973c81146d">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name can be a bit mis-leading, but this iterator does NOT return an iterator referring to the LAST element. Instead, it returns a special value that indicates this is an invalid iterator (or we're done forward-traversing) </p>
<dl class="section return"><dt>Returns</dt><dd>An "end" type iterator value</dd></dl>

</div>
</div>
<a id="aa6a729905bcedb0b493d51d8ad6af594" name="aa6a729905bcedb0b493d51d8ad6af594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a729905bcedb0b493d51d8ad6af594">&#9670;&#160;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the find method above, but using iterators (closer to std::vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to search for</td></tr>
    <tr><td class="paramname">start</td><td>Either begin, rbegin, or some other iterator to initialize the search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>And end iterator or rend/end iterator value if not found</dd></dl>

</div>
</div>
<a id="a82856a033e2fd787203e1980c912b894" name="a82856a033e2fd787203e1980c912b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82856a033e2fd787203e1980c912b894">&#9670;&#160;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>start_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first occurrence of the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to search for</td></tr>
    <tr><td class="paramname">start_index</td><td>the index to start searching at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a49f5188f57d95a55b2606583e0dc77ef" name="a49f5188f57d95a55b2606583e0dc77ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f5188f57d95a55b2606583e0dc77ef">&#9670;&#160;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds the index of the given reference value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueRef</td><td>reference to a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of value in the array</dd></dl>

</div>
</div>
<a id="adfbdc7476f393750c09dc73c9ebe439f" name="adfbdc7476f393750c09dc73c9ebe439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbdc7476f393750c09dc73c9ebe439f">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts given item at given index of the array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item being added to array</td></tr>
    <tr><td class="paramname">index</td><td>index of the array item is being added to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd03aedf6acb7f37086d83a4b5ed9dd2" name="abd03aedf6acb7f37086d83a4b5ed9dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd03aedf6acb7f37086d83a4b5ed9dd2">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new data item at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the new value to insert</td></tr>
    <tr><td class="paramname">index</td><td>the index at which to insert (must be &gt;= 0 and &lt;= size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6334ec5abee5dbc48aafcdf46a390670" name="a6334ec5abee5dbc48aafcdf46a390670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6334ec5abee5dbc48aafcdf46a390670">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the creation of a deep copy when the user assigns an existing <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> to another. This method also handles the case where the user self-copies (a = a). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> we are assigning to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<a id="aa4dedef119a00eb58d4118e45919b9d3" name="aa4dedef119a00eb58d4118e45919b9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dedef119a00eb58d4118e45919b9d3">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the [] operator to return the value by index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the desired object within an <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8f2e0b06a3bf7bdc5fbe20c95cec1c6b" name="a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e0b06a3bf7bdc5fbe20c95cec1c6b">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data item at the given index. This method (unlike at) does NOT do bounds-checking (and so is very slightly faster) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the thing to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the value at the given index</dd></dl>

</div>
</div>
<a id="addd7f6aaf5c3991f6ab2ff4bd88cb1a4" name="addd7f6aaf5c3991f6ab2ff4bd88cb1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd7f6aaf5c3991f6ab2ff4bd88cb1a4">&#9670;&#160;</a></span>output() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates output to an ostream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>std::ostream to write to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb940eeacbdef50b05dac3f2e681ab8" name="a8fb940eeacbdef50b05dac3f2e681ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb940eeacbdef50b05dac3f2e681ab8">&#9670;&#160;</a></span>output() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This basically does the same thing as the &lt;&lt; operator (the syntax is a bit different). I chose to keep it to preserve backwards compatiability with &lt;Lab3 code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream (cout, fp, stringstring, etc.) to write to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4898f36024650dee875d67083f344481" name="a4898f36024650dee875d67083f344481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4898f36024650dee875d67083f344481">&#9670;&#160;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a new instance to the beginning of the array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>object anstance being added to array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfcec39c654ee0a0d25d033809b1af44" name="abfcec39c654ee0a0d25d033809b1af44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcec39c654ee0a0d25d033809b1af44">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a backwards <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the last element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to rend. </p>
<dl class="section return"><dt>Returns</dt><dd>A backwards iterator referring to the last valid value</dd></dl>

</div>
</div>
<a id="a4aaf7be94a8d5c7c7a54cc9a4ee58763" name="a4aaf7be94a8d5c7c7a54cc9a4ee58763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaf7be94a8d5c7c7a54cc9a4ee58763">&#9670;&#160;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A valid iterator referring to the value that the user wants to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator now referring to the value <em>after</em> the value removed (or end/rend if there's nothing after)</dd></dl>

</div>
</div>
<a id="ae86f9bf49676de4539ce9c5d56ebd642" name="ae86f9bf49676de4539ce9c5d56ebd642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86f9bf49676de4539ce9c5d56ebd642">&#9670;&#160;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes item from array at given index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of item being removed</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb8ccd2d3ede88c6041032f2acb7bc17" name="afb8ccd2d3ede88c6041032f2acb7bc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8ccd2d3ede88c6041032f2acb7bc17">&#9670;&#160;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resize_if_necessary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a data item at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the thing to remove (will return a std::out_of_bounds exception if invalid (&lt;0 or &gt;= size)</td></tr>
    <tr><td class="paramname">resize_if_necessary</td><td>if true, the array will be resized if it is now below half capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data item that was just removed</dd></dl>

</div>
</div>
<a id="a3ef030038f51c7cb5b088cbd78b60d3c" name="a3ef030038f51c7cb5b088cbd78b60d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef030038f51c7cb5b088cbd78b60d3c">&#9670;&#160;</a></span>remove_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove all occurrences of the same value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>value of items being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of occurrences that were removed</dd></dl>

</div>
</div>
<a id="a47e4c18bb5fbcacabf07fb7cad038f9b" name="a47e4c18bb5fbcacabf07fb7cad038f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e4c18bb5fbcacabf07fb7cad038f9b">&#9670;&#160;</a></span>remove_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resize_if_necessary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all occurrences of a given value. Uses find and remove internally to do the removal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to remove</td></tr>
    <tr><td class="paramname">resize_if_necessary</td><td>if true, the array will be resized if it is now below half capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of occurrences of that data item that were removed</dd></dl>

</div>
</div>
<a id="a8d4c6c8324263cb02cad484f59bf0039" name="a8d4c6c8324263cb02cad484f59bf0039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4c6c8324263cb02cad484f59bf0039">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a special value indicating we're done iterating backwards or that this iterator is invalid. </p>
<dl class="section return"><dt>Returns</dt><dd>A special end value for backwards iteration</dd></dl>

</div>
</div>
<a id="a602f27aeca5467f893fe3d8f9a4a369c" name="a602f27aeca5467f893fe3d8f9a4a369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602f27aeca5467f893fe3d8f9a4a369c">&#9670;&#160;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resises array to a desired capactiy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>new desired size of array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a891330426da480ed1bbbfb29fb018b3a" name="a891330426da480ed1bbbfb29fb018b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891330426da480ed1bbbfb29fb018b3a">&#9670;&#160;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>desired_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures the internal array has at least this capacity. This is useful if the user knows how many items they will add and don't want to take the performance penalty of the grow operation happening in-between. If the capacity is already higher or equal to the given value, there will be no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_capacity</td><td>The capacity will be set to at least this value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60772231478d29dfb81a2214bc17e4f" name="af60772231478d29dfb81a2214bc17e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60772231478d29dfb81a2214bc17e4f">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets number of instances in array </p>
<dl class="section return"><dt>Returns</dt><dd>number of instances in array</dd></dl>

</div>
</div>
<a id="adbcd61184deb92c36610e47b91a7b6d5" name="adbcd61184deb92c36610e47b91a7b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcd61184deb92c36610e47b91a7b6d5">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the internal array (i.e.) how many things are being stored in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a0a3240f50cbf31ab8d25e1a336017d84" name="a0a3240f50cbf31ab8d25e1a336017d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3240f50cbf31ab8d25e1a336017d84">&#9670;&#160;</a></span>operator&lt;&lt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload the &lt;&lt; operator for easy printing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>ostream reference</td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ostream</dd></dl>

</div>
</div>
<a id="a9bb180c1f0d6bbe33037e1a8b0d6f5e4" name="a9bb180c1f0d6bbe33037e1a8b0d6f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb180c1f0d6bbe33037e1a8b0d6f5e4">&#9670;&#160;</a></span>operator&lt;&lt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the stream operator for ArrayLists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>an ostream object (ofstream, stringstream, cout, etc.) </td></tr>
    <tr><td class="paramname">alist</td><td>the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (possibly modified) os that was given to us</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ssuds/<a class="el" href="array_lists_8h_source.html">arrayLists.h</a></li>
<li>include/ssuds/<a class="el" href="oldarray_lists_8h_source.html">oldarrayLists.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
